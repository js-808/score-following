# Imports
import numpy as np
#import audio_preprocessor.preprocessor as pp
#import follower.follower as flwr
from sklearn.mixture import GaussianMixture as GMM
from filterpy import kalman

########

class ScoreFilter():
    ''' Class for performing our mixed filter to predict chord-switching times in real time
        Methods:

    '''
    def __init__(self,cqt,wav_timedata,chord_events):
        ''' Initializes model with data from the sound file and from the MIDI file
            Parameters:
                cqt (ndarray(n_bins,t)): Array of cqt sound data from preprocessor,
                        one array for each time step
                wav_timedata (tuple): Consists of tempo(float64), beat frames(ndarray),
                        and beat times(ndarray) as generated by the preprocessor.
                chord_events (List[Tuple]): A list with entries
                        [([List of chord note_values], onset_time, offset_time)]
                        (intervals should be non-intersecting, and should span
                        the entire time interval (with any silence being represented
                        by an empty list on that time interval)). Generated by preprocessor.
        '''
        # Number of chord events #
        self.n_chords = len(chord_events)
        self.chords = chord_events

        # cqt data, number of time steps #
        self.t_steps = cqt.shape[1]
        self.cqt = cqt # Maybe should be abs? #
        self.n_bins = cqt.shape[0]

        # Convert chords into CQT-compatible vectors #
        self.chord_CQT = None # TODO: Algorithm to convert #

        # Extra data in case we need it #
        self.beat_data = wav_timedata


    def _switch(self,i,t):
        ''' Decides whether or not to switch
            Parameters:
                i (int): Index of chord state
                t (t): Time index of cqt sound data at a given time
            Returns:
                switch (bool): Whether the algorithm switches or not
        '''
        # Compute probability #
        del_t = np.random.multivariate_normal(mean=np.zeros(self.n_bins),cov=np.eye(self.n_bins))
        X0 = self.chord_CQT[i] + del_t
        X1 = self.chord_CQT[i+1] + del_t
        Y_t = self.cqt[:,t]      # Might need reshaping to line up? #
        p = None # TODO How to compute?

        # Sample from the Bernoulli distribution #
        s = np.random.binomial(1,p)

        return bool(s)

    def _():
        '''
        '''

if __name__ == "__main__":
    # Tests and shit #
    print("Hello World")
